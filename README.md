# 电阻发光队电控代码

## 前言

本代码为2022中国科学技术大学 Robo Game 机器人比赛电阻发光队机器人控制程序。本程序的开发和使用旨在学习机器人控制系统、电机控制理论和相关传感器的使用，仅供学习和娱乐用途使用。

## 介绍

### 比赛要求

本届比赛要求设计一个旱地’冰壶’机器人，其能够移动到特定区域，通过特定方式识别‘冰壶’种类（红壶或黄壶），并能拾取目标‘冰壶’，将其发射到计分区域。同时机器人须符合赛事机器人制作规范、经费限制等。

### 相关硬件

#### 控制板

**主控板：**

经初期电路管脚分配发现F103系列的管脚可能不够，因此选择使用了正点原子 STM32F407ZGT6 最小系统板作为主控板，综合控制机器人的整体流程。

**辅助板：**

同时，由于初期采用自制的数字巡线模块，我们发现巡线模块所需引脚占用过多，因此又添加一块 STM32F103RCT6 最小系统板（其他课程中老师设计的系统板）作为辅助控制板，用于处理巡线信息，并将其发送给主控板。

#### 相关结构模块及部分器件

**1. 机械模块：**

带编码器的直流无刷电机（用于麦克纳姆轮）、舵机（机械爪夹取‘冰壶’）、电动推杆（推动机械部件上升下降）、按压开关（自制、控制推杆上升下降距离）

**2. 电源管理模块：**

官方分电板（电源直接连接，将电源电压划分为不同电压，驱动不同模块）、降压模块（分电板电压进一步降低到3.3V，给系统板供电）

**3. 巡线模块：**

前期使用自制的红外巡线模块，后来发现效果并不好，且模块距离地面太近；二审后改用成品模块。尝试使用测距模块来实现车辆运动距离控制，后来发现运动下测量结果很不好，于是放弃。

**4. 识别模块：**

我们并没有使用摄像头加树莓派来实现识别颜色，而是直接使用扫码模块扫‘冰壶’上的二维码（红壶与黄壶有不同的扫码值）；不过扫码效果受底色、安装距离等影响，导致最终黄色底色下可以扫描成功，而红色底色下则很难成功，这也影响了代码中的检测判断方法。

**5. 气路模块：**

气瓶（储气）、减压阀（控制输出气压大小）、电磁阀（电路控制，控制气路通断，实现‘冰壶’的发射）、气缸（’冰壶‘发射装置）

## 代码具体内容及实现流程

由于过程为单个无循环流程，因此在 `main.c` 中配置好外设，然后依次运行程序执行相关流程即可，不必放在 `while{}` 中。程序运行时，依次执行对应的函数，执行相关的操作。

### 代码结构：

```BASH
Contact_v6.0_YellowPlus
|
├─CORE     
├─FWLIB         
├─HARDWARE         
├─OBJ     
├─SYSTEM      
└─USER
```

只需要关注上述中列出的 `HARDWARE、SYSTEM、USER` 文件夹中的文件即可。

#### `USER` 文件夹：

该文件夹下 `main.c` 为主程序入口，其依次执行相应的配置函数，然后按照顺序执行相应的操作，实现目标功能。

#### `SYSTEM` 文件夹：

该文件夹进行基本的外设配置，设置了延时函数 `delay_ms()`、`delay_us()`，同时 `usart` 中配置了基本的串口及其中断函数。

其中`usart`中配置的串口`USART1`用于接收扫码模块的信息，用于判断冰壶的是否为目标冰壶。

#### `HARDWARE` 文件夹：

该文件夹下为各种外设的配置文件以及机器人程序功能的实现函数。文件夹结构如下，每个文件夹下有同名的 `.c` 和 `.h` 文件，下面分别介绍对应的文件夹内函数功能。

注意，文件夹中 `CONTACT`、`LED`、`KEY` 、`STEER`下的文件或为早期调试产生，或为程序模板预先带有的文件，实际最终并没有使用到，因此不再介绍。

```bash
├─HARDWARE
│  ├─BinaryToHex
│  │      BinaryToHex.h  
│  ├─CONTACT
│  │      contact.c
│  │      contact.h  
│  ├─EXTI
│  │      exti.c
│  │      exti.h    
│  ├─GPIO
│  │      gpio.c
│  │      gpio.h   
│  ├─KEY
│  │      key.c
│  │      key.h  
│  ├─LED
│  │      led.c
│  │      led.h  
│  ├─MOTOR
│  │      motor.c
│  │      motor.h    
│  ├─PROCEDURE
│  │      procedure.c
│  │      procedure.h
│  ├─PRO_BUFF
│  │      pro_buff.c
│  │      pro_buff.h   
│  ├─PRO_SUPPORT
│  │      pro_support.c
│  │      pro_support.h
│  ├─PWM
│  │      pwm.c
│  │      pwm.h
│  ├─STEER
│  │      steer.c
│  │      steer.h
│  ├─TIMER
│  │      timer.c
│  │      timer.h
│  └─USART3
│          usart3.c
│          usart3.h
```

**1. BinaryToHex：**

即二进制数字转十六进制，调用该 `.h`文件可以方便巡线数据的转换，节省数据空间。

**2. EXTI：**

其中定义了用于设置外部中断的配置函数，在外部中断（`EXIT0` 接收上方开关的信号、`EXIT3` 接收下方开关的信号）中接收来自上下两个按压开关的信号，从而控制推杆的上升和下降以及其大致距离。注意，由于受到硬件精度的影响，推杆可能无法完全降到底，因此在对应的中断函数中添加了延时。

同时编写了推杆上升 `actuator_up()`、下降 `actuator_down()`及停止 `actuator_stop()` 的控制函数。

**3. GPIO: **

其中定义了部分外设需要使用的通用IO引脚（如电机正反转、外部中断、电磁阀控制等）的配置函数，不过由于实际使用引脚的位置在不同的函数中，很容易对引脚反复定义。其中 `.h`文件将了用于控制四个电机正反转的控制引脚进行了封装。

**4. MOTOR:**

比赛前期准备使用`PID`来控制车辆运动，后来发现`PID` 调参总是效果总不好，即使使用输出限幅等方式，轮子间转动总会相互干扰，也可能是硬件电路搭建有问题，最终没有找到解决方法，因此放弃该方式，采用`PWM`直接控制，手动调节每个轮子在固定速度下的`PWM`占空比，再通过某个轮子的计数器值来判断大致的运动距离。

该文件定义了计数器 `TIM3` 的配置函数，利用其内部中断函数`TIM3_IRQHandler`不断判断轮子的返回的编码器的值（是否达到目标值）从而控制运动距离。不过可能由于配置等方面问题，不同轮子运动相同距离编码器值偏差有时可能较大，需要自己筛选一个’可信‘的轮子。

同时文件中定义了不同情况下车辆的运动控制函数（代码中有注释），除了行走固定距离那种情况，其他控制车辆运动的方式都需要结合延时函数等来控制运动距离。

最后为`PMW`设置函数`pwm_set()`，其中我们要根据目标速度、运动方向设定四个轮子的`PWM`波占空比，由于上述情况，每种情况都需要对占空比进行微调，使得最终运动效果达到预期。

**5. PRO_BUFF:**

其中定义了机器人取高难度壶并发射的逻辑运动流程。

其中函数`HardPart2()`定义了高难度区冰壶判断方式。由于扫码模块在红色底色下扫码效果不稳定，很难正常扫码，黄色底色下较容易扫码；因此需要考虑未扫码成功的情况。扫码不成功将不会返回值，我们通过延时加计数的方式，通过返回值以及计数值来综合判断所夹的壶颜色（计数值`num`大于10则认为是红壶）。

**6. PRO_SUPPORT:**

该文件中定义了三类函数：

1. 一类是判断循迹模块的情况，包括函数：

   巡线模块（红外对管）按六个一组（按顺序编号），安装在车辆的四个方向，同时按顺时针方向从0开始编号（车正前方为0，右方为1）。

   `sum_location(u8 i)`：判断该编号`i`的边是否检测到黑线。

   `most_right(u8 i)`:从编号最小的一端找到边`i`上首先检测到黑线的模块，并返回对应编号。

   `most_front(u8 i)`：从编号最大的一端找到边`i`上首先检测到黑线的模块，并返回对应编号。

   `NumOfLight(u8 i)`：边 `i`上亮灯的个数（检测到黑线的模块数）

2. 另一类是夹壶机构控制以及电磁阀控制函数，包括：

   `SteerControl(u8 i)`：控制舵机转到对应角度（夹壶机构张开对应角度）。由于不同场地下情况不同，需要分别设置对应的夹角，参数`i`为不同情况的标号。

   `FireTheGoal(void)`：电磁阀控制函数，控制气路的通断，实现气缸的发射与收回。

3. 最后是姿态调整模块，由于机器人直线运动有偏差，需要利用循迹情况来调整位置。函数包括：

   `PerformBetter(void)`：进行姿态调整，通过先旋转，再左右移动，再前后移动来使循迹模块的中间两个检测到黑线，调正姿态。

   `move_lr()`：在发壶之前进行姿态调整。我们利用发壶区的两个桩子将前后方向调整好，但需要将车辆移动到中心，因此需要左右移动到中间位置。

   `pass_one_line(void)`：即经过一条黑线，调用该函数可以用于车辆越过一条黑线（经过一条黑线后才跳出）。

   `pass_one_line_hard(void)`：同上，只不过用在高难度区。

**7. PROCEDURE:**

其中定义了机器人取低难度壶并发射的逻辑运动流程，以及机器人从出发到达取壶区的流程。

函数`MoveToCentr(void)`等为机器人从等待区出发到取壶区的流程。

需要注意，从等待区到取壶区有一段复杂的循迹，我们选择无视循迹路线，直接直线运动到取壶区（`MoveToCentr3(void)`函数）。这里我们用`PWM`来控制运动，利用设置计数器值来控制运动距离`run_backward(5200)`。虽然比赛前效果不错，但比赛时确故障频出。

函数`EasyPart1(void)`等为机器人取低难度壶并发射的逻辑运动流程。

**8. PWM:**

该文件中定义了两个电动推杆，四个电机的`PWM`控制信号输出端口的配置函数。其中对应`GPIO`口的配置可能在文件`gpio.h`中配置过一次，需要注意。

**9. TIMER:**

其中定义了接收四个电机编码器的输入捕获端口的配置函数。采用输入捕获分别接收四个电机的编码器值，仅采用了单个通道来捕获，一开始想利用此编写`PID`控制算法，后来发现效果很差，期间还一直出现电机的bug，最后只用于判断电机的运行距离。但最终效果也不太好。

**10. USART3:**

其中定义了串口`USART3`的配置函数，其用于接收和转换辅助板传来的循迹信息。

### 辅助板中代码文件

辅助板作用比较单一，即是接收和处理循迹信息并发送给主控板。

#### `HARDWARE`文件夹：

辅助板代码文件为`Trace5.2`，其中仅需要关注`HARDWARE`文件夹即可，其中有三个文件夹`trace_pin`、`trace_tim`、`USART3`。

**1. trace_pin**

其中定义了用于接收每个循迹模块信息的`GPIO`端口的配置函数。尽量将其设置到同一个`GPIO`组上，可以方便后期的读取。

**2. trace_tim**

其中定义了定时器`TIM2`的配置函数，通过`TIM2`的定时器中断，每隔一段时间通过`USART1`向主控板发送循迹信息。

**3. USART3**

其中定义了串口`USART3`的配置函数。

需要注意的是当使用`USART_SendData(USART_TypeDef* USARTx, uint16_t Data)`函数时，其只能传输八位或九位的数据，而不能一次传输16位数据，即使其参数为`uint16_t Data`。这对F103和F407都一样。同时接收函数`USART_ReceiveData(USART_TypeDef* USARTx)`返回值也是一样。

